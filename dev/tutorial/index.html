<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SpeedMapping.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/SpeedMapping.jl/stable/tutorial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpeedMapping.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Avoiding-memory-allocation"><span>Avoiding memory allocation</span></a></li><li><a class="tocitem" href="#Working-with-scalars"><span>Working with scalars</span></a></li><li class="toplevel"><a class="tocitem" href="#Solving-non-linear-systems-of-equations"><span>Solving non linear systems of equations</span></a></li><li class="toplevel"><a class="tocitem" href="#Minimizing-a-function"><span>Minimizing a function</span></a></li><li><a class="tocitem" href="#Adding-box-constraint"><span>Adding box constraint</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NicolasL-S/SpeedMapping.jl/blob/main/docs/src/tutorial.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p><code>speedmapping(x0; kwargs...)</code>  solves three types of problems:</p><ol><li><a href="#Accelerate-convergent-mapping-iterations">Accelerating convergent mapping iterations</a></li><li><a href="#Solve-non-linear-systems-of-equations">Solving non-linear systems of equations</a></li><li><a href="#Minimize-a-function">Minimizing a function, possibly with box constraints</a></li></ol><p>using two algorithms:</p><ul><li>Alternating cyclic extrapolations (<strong>ACX</strong>) <a href="https://www.sciencedirect.com/science/article/abs/pii/S0377042723005514">Lepage-Saucier, 2024</a></li><li>Anderson Acceleration (<strong>AA</strong>) <a href="https://dl.acm.org/doi/10.1145/321296.321305">Anderson, 1964</a></li></ul><p>This tutorial will display its main functionality on simple problems. To see which specification may be more performant for your problem, the <strong>Benchmarks</strong> section compares all of them, along with other Julia packages with similar functionalities.</p><h1 id="Accelerating-convergent-mapping-iterations"><a class="docs-heading-anchor" href="#Accelerating-convergent-mapping-iterations">Accelerating convergent mapping iterations</a><a id="Accelerating-convergent-mapping-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Accelerating-convergent-mapping-iterations" title="Permalink"></a></h1><p>Let&#39;s find the dominant eigenvalue of a matrix <span>$A$</span> using the accelerated <a href="https://en.wikipedia.org/wiki/Power_iteration">Power iteration</a>.</p><pre><code class="language-julia hljs">using LinearAlgebra

n = 10;
A = ones(n,n) .+ Diagonal(1:n);

# An in-place mapping function to avoid allocations
function power_iteration!(xout, xin, A)
    mul!(xout, A, xin)
    maxabs = 0.
    for xi in xout
        abs(xi) &gt; maxabs &amp;&amp; (maxabs = abs(xi))
    end
    xout ./= maxabs
end;
x0 = ones(n);</code></pre><p>Speedmapping has one mandatory argument: the starting point <span>$x0$</span>. The mapping is specified with the keyword argument <span>$m!$</span>.</p><pre><code class="language-julia hljs">using SpeedMapping
res = speedmapping(x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, A));
display(res)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">• minimizer: 10-element Vector{Float64}:
 0.4121491397959738
 0.4409506028458422
 0.47407986435268584
 0.5125916155854076
 0.5579135744375137
 0.6120273732149385
 0.6777660401920018
 0.7593262778315447
 0.8632012008768285
 1.0

Result of SpeedMapping, acx algo
• maps: 16  • iterations: 6  • residual_norm: = 3.664942616680641e-9
• status: first_order</code></pre><p>The dominant eigenvalue is:</p><pre><code class="language-julia hljs">v = res.minimizer; ## The dominant eigenvector
dominant_eigenvalue = v&#39;A*v/v&#39;v;
eigen(A).values[10] ≈ dominant_eigenvalue</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>With <code>m!</code>, the default algorithm is <code>algo = :acx</code>. To switch, set <code>algo = :aa</code>.</p><pre><code class="language-julia hljs">res_aa = speedmapping(x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, A), algo = :aa);
display(res_aa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">• minimizer: 10-element Vector{Float64}:
 0.412149137089775
 0.44095060327353647
 0.47407986082156256
 0.5125916088599349
 0.5579135698434506
 0.6120273645599557
 0.6777660340915559
 0.7593262700274771
 0.8632011949395236
 1.0

Result of SpeedMapping, aa algo
• maps: 12  • iterations: 11  • residual_norm: = 7.238700125150564e-9
• status: first_order</code></pre><p>By default, <strong>AA</strong> uses <a href="https://arxiv.org/abs/2408.16920">adaptive relaxation</a>, which can reduce the number of iterations. It is specified by the keyword argument <code>adarelax = :minimum_distance</code>. For constant relaxation, set <code>adarelax = :none</code>.</p><pre><code class="language-julia hljs">res = speedmapping(x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, A), algo = :aa, adarelax = :none);</code></pre><p>Another recent development for <strong>AA</strong> is <strong>Composite AA</strong> by <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/nme.7096">Chen and Vuik, 2022</a>. A one-step <strong>AA</strong> iteration (using 2 maps) is inserted between 2 full <strong>AA</strong> steps, which reduces the computation and can speed-up some applications. The default is <code>composite = :none</code>. Two versions are available:</p><pre><code class="language-julia hljs">res = speedmapping(x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, A), algo = :aa, composite = :aa1);
res = speedmapping(x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, A), algo = :aa, composite = :acx2);</code></pre><p>Some mapping iterations maximize or minimize a certain objective function. Since some <strong>AA</strong> steps can deteriorate the objective, it would be best to avoid them by falling back to the last map. This can be done by supplying an objective function (assumed to be a minimization problem) using <code>f</code> as keyword argument. Here is an illustrative <a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm">EM-algorithm</a> example from <a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.1969.10501071">Hasselblad (1969)</a>.</p><pre><code class="language-julia hljs">function neg_log_likelihood(x)
    freq = (162, 267, 271, 185, 111, 61, 27, 8, 3, 1)
    p, μ1, μ2 = x
    yfact = μ1expy = μ2expy = 1
    log_lik = 0
    for y in eachindex(freq)
        log_lik += freq[y] * log((p * exp(-μ1) * μ1expy + (1 - p) * exp(-μ2) * μ2expy) / yfact)
        yfact *= y
        μ1expy *= μ1
        μ2expy *= μ2
    end
    return -log_lik # Negative log likelihood to get a minimization problem
end

function EM_map!(xout, xin)
    freq = (162, 267, 271, 185, 111, 61, 27, 8, 3, 1)
    p, μ1, μ2 = xin
    sum_freq_z1 = sum_freq_z2 = sum_freq_y_z1 = sum_freq_y_z2 = 0
    μ1expy = μ2expy = 1
    for i in eachindex(freq)
        z = p * exp(-μ1) * μ1expy / (p * exp(-μ1) * μ1expy + (1 - p) * exp(-μ2) * μ2expy)
        sum_freq_z1   += freq[i] * z
        sum_freq_z2   += freq[i] * (1 - z)
        sum_freq_y_z1 += (i - 1) * freq[i] * z
        sum_freq_y_z2 += (i - 1) * freq[i] * (1 - z)
        μ1expy *= μ1
        μ2expy *= μ2
    end
    xout .= (sum_freq_z1 / sum(freq), sum_freq_y_z1 / sum_freq_z1, sum_freq_y_z2 / sum_freq_z2)
end

res_with_objective = speedmapping([0.25, 1., 2.]; f = neg_log_likelihood, m! = EM_map!, algo = :aa);
display(res_with_objective)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">• minimizer: 3-element Vector{Float64}:
 0.35988539821029
 1.2560951029223146
 2.6634043582726785

Result of SpeedMapping, aa algo
• maps: 18  • f_calls: 24  • iterations: 17  • residual_norm: = 1.2074325435679254e-10
• status: first_order</code></pre><h2 id="Avoiding-memory-allocation"><a class="docs-heading-anchor" href="#Avoiding-memory-allocation">Avoiding memory allocation</a><a id="Avoiding-memory-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#Avoiding-memory-allocation" title="Permalink"></a></h2><p>For similar problems solved many times, it is possible to preallocate working memory and feed it using the <code>cache</code> keyword argument. Each algorithm has its own cache:</p><pre><code class="language-julia hljs">acx_cache = AcxCache(x0);
aa_cache = AaCache(x0);</code></pre><p>Note that <span>$x0$</span> must still be supplied to speedmapping.</p><p>For small-sized problems with <strong>ACX</strong>, heap-allocation can be avoided by supplying a static array or a tuple as starting point and using the keyword argument <code>m</code> for the mapping function, offering additional speed gains.</p><pre><code class="language-julia hljs">using StaticArrays

function power_iteration(xin, A)
    xout = A * xin;
    maxabs = 0.;
    for xi in xout
        abs(xi) &gt; maxabs &amp;&amp; (maxabs = abs(xi))
    end;
    return xout / maxabs;
end;

As = @SMatrix ones(n,n);
As += Diagonal(1:n);
x0s = @SVector ones(n);

res_static = speedmapping(x0s; m = x -&gt; power_iteration(x, As));</code></pre><p>Comparing speed gains</p><pre><code class="language-julia hljs">using BenchmarkTools, Unitful

bench_eigen = @benchmark eigen($A);
bench_alloc = @benchmark speedmapping($x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, $A));
bench_prealloc = @benchmark speedmapping($x0; m! = (xout, xin) -&gt; power_iteration!(xout, xin, $A), cache = $acx_cache);
bench_nonalloc = @benchmark speedmapping($x0s; m = x -&gt; power_iteration(x, $As));
times = Int.(round.(median.([bench_eigen.times, bench_alloc.times, bench_prealloc.times, bench_nonalloc.times])))/1000 .* u&quot;μs&quot;;
return hcat([&quot;eigen&quot;, &quot;Allocating&quot;, &quot;Pre-allocated&quot;, &quot;Non allocating&quot;],times)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 Matrix{Any}:
 &quot;eigen&quot;           14.598 μs
 &quot;Allocating&quot;       2.447 μs
 &quot;Pre-allocated&quot;    2.167 μs
 &quot;Non allocating&quot;   1.363 μs</code></pre><h2 id="Working-with-scalars"><a class="docs-heading-anchor" href="#Working-with-scalars">Working with scalars</a><a id="Working-with-scalars-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-scalars" title="Permalink"></a></h2><p><code>m</code> also accepts scalars and tuples.</p><pre><code class="language-julia hljs">speedmapping(0.5; m = cos);
speedmapping((0.5, 0.5); m = x -&gt; (cos(x[1]), sin(x[2])));</code></pre><h1 id="Solving-non-linear-systems-of-equations"><a class="docs-heading-anchor" href="#Solving-non-linear-systems-of-equations">Solving non linear systems of equations</a><a id="Solving-non-linear-systems-of-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-non-linear-systems-of-equations" title="Permalink"></a></h1><p>For non-linear systems of equations (finding <span>$x^*$</span> such that <span>$G(x^*) = 0$</span>), only <strong>AA</strong> with constant relaxation should be used (and is set by default). The keyword argument to supply <span>$G$</span> is <code>r!</code>.</p><pre><code class="language-julia hljs">function r!(resid, x)
	resid[1] = x[1]^2;
	resid[2] = (x[2] + x[1])^3;
end

speedmapping([1.,2.]; r! = r!);</code></pre><h1 id="Minimizing-a-function"><a class="docs-heading-anchor" href="#Minimizing-a-function">Minimizing a function</a><a id="Minimizing-a-function-1"></a><a class="docs-heading-anchor-permalink" href="#Minimizing-a-function" title="Permalink"></a></h1><p>To minimize a function (using <strong>ACX</strong>), the function and its in-place gradient are supplied with the keyword arguments <code>f</code> and <code>g!</code>. The Hessian cannot be supplied. Compared to other quasi-Newton algorithms like L-BFGS, <strong>ACX</strong> iterations are very fast, but the algorithm may struggle for ill-conditioned problems.</p><pre><code class="language-julia hljs">f_Rosenbrock(x) = 100 * (x[1]^2 - x[2])^2 + (x[1] - 1.)^2;

function g_Rosenbrock!(grad, x) # Rosenbrock gradient
	grad[1] = 400 * (x[1]^2 - x[2]) * x[1] + 2 * (x[1] - 1);
	grad[2] = -200 * (x[1]^2 - x[2]);
end

display(speedmapping([-1.2, 1.]; f = f_Rosenbrock, g! = g_Rosenbrock!))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">• minimizer: 2-element Vector{Float64}:
 0.9999999999999285
 0.9999999999998567

Result of SpeedMapping, acx algo
• maps: 88  • f_calls: 5  • iterations: 33  • residual_norm: = 6.732603331104633e-14
• status: first_order</code></pre><p>The function objective is only used to compute a safer initial learning rate. It can be omitted.</p><pre><code class="language-julia hljs">speedmapping([-1.2, 1.]; g! = g_Rosenbrock!);</code></pre><p>If only the objective is supplied, the gradient is computed using using ForwardDiff.</p><pre><code class="language-julia hljs">speedmapping([-1.2, 1.]; f = f_Rosenbrock);</code></pre><p>The keyword argument g can be used with static arrays or tuple to supply a non-allocating gradient.</p><pre><code class="language-julia hljs">using StaticArrays
g_Rosenbrock(x :: StaticArray) = SA[400 * (x[1]^2 - x[2]) * x[1] + 2 * (x[1] - 1), -200 * (x[1]^2 - x[2])];
speedmapping(SA[-1.2, 1.]; g = g_Rosenbrock);

g_Rosenbrock(x :: Tuple) = (400 * (x[1]^2 - x[2]) * x[1] + 2 * (x[1] - 1), -200 * (x[1]^2 - x[2]));
speedmapping((-1.2, 1.); g = g_Rosenbrock);</code></pre><p>Scalar functions can also be supplied. E.g. <span>$f(x) = e^x + x^2$</span></p><pre><code class="language-julia hljs">res_scalar = speedmapping(0.; f = x -&gt; exp(x) + x^2, g = x -&gt; exp(x) + 2x);
display(res_scalar)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">• minimizer: -0.3517337140823905

Result of SpeedMapping, acx algo
• maps: 8  • f_calls: 5  • iterations: 3  • residual_norm: = 7.659449519081818e-9
• status: first_order</code></pre><h2 id="Adding-box-constraint"><a class="docs-heading-anchor" href="#Adding-box-constraint">Adding box constraint</a><a id="Adding-box-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-box-constraint" title="Permalink"></a></h2><p>An advantage of <strong>ACX</strong> is that constraints on parameters have little impact on estimation speed. They are added with the keyword arguments <code>lower</code> and <code>upper</code> (<code>= nothing</code> by default). The starting point does not need to be in the feasible domain, but, if supplied, upper / lower <em>need to be of type x0</em>.</p><pre><code class="language-julia hljs">speedmapping([-1.2, 1.]; f = f_Rosenbrock, g! = g_Rosenbrock!, lower = [2, -Inf]);
speedmapping(0.; g = x -&gt; exp(x) + 2x, upper = -1.);</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 20 August 2025 02:11">Wednesday 20 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
